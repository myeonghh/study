# Quest 02. CSS의 기초와 응용

>## Checklist
* >**CSS를 HTML에 적용하는 세 가지 방법은 무엇일까요?**
    1. 인라인 방식 
        <br>태그안에 style속성을 줘서 직접 css를 작성하는 방법.
        <br>css를 작성한 해당 태그컨텐츠에만 스타일이 적용된다.
        ```html
        <span style="color: blue; font-size: 20px;">인라인 방식</span>
        ```
    2. 내부 방식
        <br>HTML문서내에 `<style>` 태그를 사용하여 그안에 css 를 작성하는 방법.
        <br>보통 `<head>` 태그 사이에 `<style>` 태그를 작성하지만, HTML 문서의 어디에 넣어도 잘 적용된다.
        <br> css를 작성한 해당 HTML 문서에만 스타일이 적용된다.
        ```html
        <html>
            <head>
                <style>
                    .test {
                        color: red;
                        font-weight: bolder;
                    }
                </style>  
            </head>
            <body>
                <span class="test">내부 방식</span>
            </body>
        </html>
        ```
    3. 외부 방식
        <br> 별도의 css 파일을 만들고 HTML 문서와 연결하는 방법. 보통 가장많이 사용하는 방법이다. 
        <br> 스타일 적용을 원하는 HTML문서 `<head>` 태그 사이에 `<link rel="stylesheet" href="css파일명.css">` 태그를 추가해서 연결시킬 수 있다.
        ```css
        .test2 {
            color: green;
            font-size: 30px;
        }
        ```
        ```html
        <html>
            <head>
                <link rel="stylesheet" href="cssTest.css">
            </head>
            <body>
                <span class="test2">외부 방식</span>
            </body>
        </html>
        ```
        
* >**세 가지 방법 각각의 장단점은 무엇일까요?**
     
     ||장점|단점|
     |---|---|---|
     |인라인방식|하나의 태그에 단순한 스타일을 적용할때 편하다.<br>특정 태그에 어떤 스타일을 적용시켰는지 직관적으로 알기 쉽다.|복잡한 스타일을 주는데 한계가 있고, 스타일 일괄 적용이나 일괄 변경 등의 작업을 할 때 매우 비효율적이다.|
     |내부방식|외부 CSS 파일을 수정할 수 없는 환경에서 활용가능하다. <br>간단한 내부개발을 할때 CSS를 미리 적용시켜 볼 수 있다.|CSS 내용이 많아지는 경우 HTML문서가 길고 복잡해지며, 코드의 재사용과 유지보수가 불편하다.|
     |외부방식|하나의 CSS파일만 만들어놓아도 여러 개의 HTML 문서에 적용시킬 수 있기 때문에, 코드의 재사용과 유지보수가 편리하다.|소수의 태그에 빠르게 스타일을 적용하고 싶을때 인라인방식보다 불편하다.|

* >**CSS 규칙의 우선순위는 어떻게 결정될까요?**
     
    css 규칙의 우선순위(캐스캐이딩)는 다음 세가지 규칙에 의해서 결정된다.   
     1. 중요도   
        CSS가 어디에 선언 되었는지에 따라서 우선순위가 달라진다.
     2. 명시도   
        대상을 명확하게 특정할수록 명시도가 높아지고 우선순위가 높아진다.
     3. 선언순서   
        선언된 순서에 따라 우선 순위가 적용된다. 즉, 나중에 선언된 스타일이 우선 적용된다.   
        
    <br> => 이러한 세가지 규칙을 바탕으로 점수가 매겨져, 점수가 높은 선언이 우선된다.   
    => 점수가 같으면 내부방식이 외부방식보다 우선이며, 가장 마지막에 해석된 선언이 우선된다. 

    |순위| 선언| 점수
    |---|---|---|
    |1|!important; (속성 값 옆에 작성)|무한대|
    |2|인라인 선언|1000점|
    |3|ID 선택자|100점|
    |4|Class 선택자|10점|
    |5|태그 선택자|1점|
    |6|전체 선택자|0점|

* >**CSS의 박스모델은 무엇일까요? 박스가 화면에서 차지하는 크기는 어떻게 결정될까요?**   
   
   => 모든 HTML 요소는 박스모양으로 구성되며, 이것을 박스 모델이라고 부른다.   
   => 박스 모델은 HTML 요소를 패딩(padding), 테두리(border), 마진(margin), 그리고 내용(content)으로 구분한다.
   <br><br><img src="img_css_boxmodel.png">
      
  |구성요소|설명|
  |---|---|
  |content|텍스트나 이미지가 들어가는 박스의 실질적인 내용부분이다. <br>width와 height속성으로 넓이와 높이를 지정할 수 있다.|
  |padding|내용과 테두리 안쪽에 위치하는 내부 여백영역이다.|
  |border|내용과 패딩 주변을 감싸는 테두리이다.|
  |margin|테두리 바깥에 위치하는 요소의 외부 여백 영역이다.|

  ✔ ***박스가 화면에서 차지하는 크기***    

  박스 너비 = width 속성값 + 2 * (padding 속성값 + border-width 속성값 + margin 속성값)   
  박스 높이 = height 속성값 + 2 * (padding 속성값 + border-width 속성값 + margin 속성값)

* >**`float` 속성은 왜 좋지 않을까요?**   
      
     자식 요소에 float 속성을 적용하면, 부모 요소는 해당 자식 요소가 존재하지 않는 것으로 판단하여, 부모 요소가 해당 자식 요소의 높이를 인식하지 못하는 문제가 발생한다.  
     때문에 float속성을 가진 자식요소가 부모 요소의 영역을 벗어나는 경우가 생긴다.   
     
     ==> 부모요소에 overflow: hidden; 속성을 추가하거나, ::after 가상 요소 선택자에 clear: both; 속성을 추가해서 해결할 수는 있지만 번거롭다.
* >**Flexbox(Flexible box)와 CSS Grid의 차이와 장단점은 무엇일까요?**
    
    ||차이|장점|단점|
    |---|---|---|---|
    |Flex|Flex는 1차원으로 수평, 수직 영역 중 하나의 방향으로만 레이아웃을 구성할 수 있다.|요소의 사이즈가 불명확하거나 동적으로 변화할 때에도 유연한 레이아웃을 구성할 수 있다. 때문에 Flexbox는 소규모 레이아웃을 구성하는데 적합하다.|여러개의 행과 열로 이루어진 더 복합적인 레이아웃을 구성하는데 어려움이있다.|
    |Grid|Grid는 2차원으로 수평, 수직 영역을 동시에 레이아웃을 구성할 수 있다.|여러개의 행과 열로 이루어진 웹페이지를 만드는데 유용하다. 때문에 Grid는 대규모 레이아웃을 구성하는데 적합하다.|인터넷 익스플로러의 예전버전에선 지원하지 않을 수 있다.|
* >**CSS의 비슷한 요소들을 어떤 식으로 정리할 수 있을까요?**
   
   * css를 작성할때 비슷한 요소들이 있는 경우에는 해당 선택자들을 ',(콤마)' 로 묶어서 스타일을 일괄 적용할 수 있다.
   * 비슷한 요소를 갖는 해당 HTML 태그들에 클래스명을 지정할때 띄어쓰기 공백을 주어서 또 다른 동일한 클래스명을 부여하여 하나의 클래스 선택자로  스타일을 일괄 적용할 수 있다.
---

>## Advanced
* >**왜 CSS는 어려울까요?**
    1. 어떤 CSS 규칙이 최종적으로 적용될지 예측하기 어렵다.
       
       CSS에서 중복 선언된 규칙 중 어떤 것이 최종적으로 적용될지는 간단한 알고리즘이기 때문에 쉽게 예측할 수 있지만, 문제는 CSS 속성은 어디서든 선언될 수 있기 때문에 선언된 모든 규칙을 빠짐없이 파악하는데 어려움이 있다. 이걸 보통 글로벌 네임스페이스 문제라고 부른다.
    2.  CSS 규칙의 상호작용을 모두 알기 어렵다.
      
        CSS 속성은 대부분 다른 속성과 상호작용을 하여 결과값을 내는데, 대부분의 경우 속성의 이름만 보고 상호작용을 예상하기가 어렵다.
    3. 런타임 환경을 예상하기 어렵다.
    
        웹브라우저의 버전과 개발사, 심지어 운영체제도 CSS 결과값에 영향을 줄 수있기 때문에 예상하기가 어렵다. 예를 들어서 MacOS와 Windows 운영체제는 서로 폰트 렌더링 방식이 다르기 때문에 font-weight 값이 같더라도 MacOS에서 폰트가 조금 더 두껍게 출력된다.
* >**CSS의 어려움을 극복하기 위해 어떤 방법들이 제시되고 나왔을까요?**
  
    ||설명|
    |---|---|
    |BEM|CSS 특유의 글로벌 네임스페이스에서도 이름이 중복되지 않도록 CSS 아이디와 클래스를 명명하는 방법론인 BEM 방법론이 제시되었다.|
    |CSS Modules|각 파일에 선언된 CSS 선택자에 고유한 해시 문자열을 추가하여, 해당 선택자가 각 파일의 네임스페이스에서만 동작하도록 자동적으로 관리해주는 CSS Modules이 나오게 되었다.|
    |CSS in JS|CSS의 문제를 해결하기 위해서 CSS를 JS를 통해서 만들 수 있는 CSS in JS가 탄생하였다.|
    |TailwindCSS|class명에 유틸리한 이름을 붙여서 CSS를 적용하는 CSS프레임워크인 Tailwind가 등장하였다.|
 
* >**CSS가 브라우저에 의해 해석되고 적용되기까지 내부적으로 어떤 과정을 거칠까요?**
    
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmgD0m%2FbtrqX1FEug9%2FJB006wdSNgJbk9OJltdNO0%2Fimg.jpg">
    
    1. 브라우저가 html 문서를 서버에서 받아서 로드한다.
    2. html 문서를 parsing 하여 DOM 으로 변환한다. 
    3. html 문서에 연결된 CSS를 가지고 온다.
    4. 브라우저는 가져온 CSS 구문을 분석하고, 규칙에 따라 정렬하여 렌더링트리를 구성한다.
    5. 구성된 렌더링는 규칙이 적용된 후 표시되어야 하는 구조에 맞게 배치된다.
    6. 시각적으로 페이지에 표시된다. (Painting 단계)  
  
* >**웹 폰트의 경우에는 브라우저 엔진 별로 어떤 과정을 통해 렌더링 될까요?**
   
   <img src="https://web-dev.imgix.net/image/admin/NgSTa9SirmikQAq1G5fN.png?auto=format&w=845">

    * 페이지에서 지정된 텍스트를 렌더링 하는데 필요한 글꼴 변형을 렌더링 트리가 표시한 후 글꼴 요청이 전달한다.
    * 글꼴을 아직 사용할 수 없는 경우 브라우저에서 텍스트 픽셀을 렌더링 하지 못할 수 있다.
    * 글꼴을 사용할 수 있게 되면 브라우저는 텍스트 픽셀을 그린다.